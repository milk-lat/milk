<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>贪吃蛇 - 小游戏乐园</title>
  <link rel="stylesheet" href="../../styles.css">
  <style>
    canvas { background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.12); border-radius: 12px; width: 100%; height: auto; max-width: 480px; }
    .hud { text-align:center; color: var(--muted); margin-top: 8px; }
  </style>
</head>
<body>
  <div class="game-page center" style="flex-direction:column;">
    <div class="game-header" style="width:100%; max-width: 520px;">
      <a class="back" href="../../">← 返回首页</a>
      <h2>贪吃蛇</h2>
      <div class="game-actions"><button id="resetBtn">重开</button></div>
    </div>

    <canvas id="canvas" width="400" height="400"></canvas>
    <div class="hud"><span id="score">得分：0</span> · <span id="speed">速度：1x</span></div>

    <div class="dpad" aria-label="方向控制">
      <div class="empty"></div>
      <button id="up">▲</button>
      <div class="empty"></div>
      <button id="left">◀</button>
      <div class="empty"></div>
      <button id="right">▶</button>
      <div class="empty"></div>
      <button id="down">▼</button>
      <div class="empty"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const speedEl = document.getElementById('speed');
    const resetBtn = document.getElementById('resetBtn');

    const CELL = 20; // 20px cell
    const COLS = canvas.width / CELL;
    const ROWS = canvas.height / CELL;

    let snake, dir, food, score, speed, loopId, pendingDir;

    function randomCell() {
      return {
        x: Math.floor(Math.random() * COLS),
        y: Math.floor(Math.random() * ROWS)
      };
    }

    function spawnFood() {
      let f;
      do { f = randomCell(); }
      while (snake.some(s => s.x === f.x && s.y === f.y));
      return f;
    }

    function reset() {
      snake = [{x: 8, y: 10}, {x: 7, y: 10}, {x: 6, y: 10}];
      dir = {x: 1, y: 0};
      pendingDir = null;
      food = spawnFood();
      score = 0;
      speed = 1; // multiplier
      scoreEl.textContent = `得分：${score}`;
      speedEl.textContent = `速度：${speed}x`;
      if (loopId) cancelAnimationFrame(loopId);
      loop();
    }

    function drawCell(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * CELL, y * CELL, CELL - 1, CELL - 1);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawCell(food.x, food.y, '#8ef0a4');
      snake.forEach((s, i) => drawCell(s.x, s.y, i === 0 ? '#6ea8fe' : 'rgba(255,255,255,.7)'));
    }

    let last = 0;
    function loop(ts = 0) {
      loopId = requestAnimationFrame(loop);
      const interval = 120 / speed; // ms per step
      if (ts - last < interval) return;
      last = ts;

      if (pendingDir) { dir = pendingDir; pendingDir = null; }

      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
      // wrap around
      head.x = (head.x + COLS) % COLS;
      head.y = (head.y + ROWS) % ROWS;

      // collision with self
      if (snake.some((s, i) => i && s.x === head.x && s.y === head.y)) {
        gameOver();
        return;
      }

      snake.unshift(head);
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        if (score % 50 === 0) { speed = Math.min(5, speed + 1); speedEl.textContent = `速度：${speed}x`; }
        scoreEl.textContent = `得分：${score}`;
        food = spawnFood();
      } else {
        snake.pop();
      }

      draw();
    }

    function gameOver() {
      cancelAnimationFrame(loopId);
      ctx.fillStyle = 'rgba(11,16,32,.7)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ff7a90';
      ctx.font = '28px Inter, system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('游戏结束 - 点击重开', canvas.width/2, canvas.height/2);
    }

    function setDir(nx, ny) {
      // Prevent reverse
      if (nx === -dir.x && ny === -dir.y) return;
      pendingDir = { x: nx, y: ny };
    }

    // Keyboard
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') setDir(0,-1);
      else if (e.key === 'ArrowDown') setDir(0,1);
      else if (e.key === 'ArrowLeft') setDir(-1,0);
      else if (e.key === 'ArrowRight') setDir(1,0);
      else if (e.key.toLowerCase() === 'r') reset();
    });

    // Touch swipe
    let touchStart = null;
    canvas.addEventListener('touchstart', (e) => { touchStart = e.touches[0]; });
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });
    canvas.addEventListener('touchend', (e) => {
      if (!touchStart) return;
      const end = e.changedTouches[0];
      const dx = end.clientX - touchStart.clientX;
      const dy = end.clientY - touchStart.clientY;
      if (Math.abs(dx) > Math.abs(dy)) setDir(dx > 0 ? 1 : -1, 0);
      else setDir(0, dy > 0 ? 1 : -1);
      touchStart = null;
    });

    // D-Pad buttons
    document.getElementById('up').onclick = () => setDir(0,-1);
    document.getElementById('down').onclick = () => setDir(0,1);
    document.getElementById('left').onclick = () => setDir(-1,0);
    document.getElementById('right').onclick = () => setDir(1,0);

    resetBtn.addEventListener('click', reset);
    canvas.addEventListener('click', () => reset());

    reset();
    draw();
  </script>
</body>
</html>